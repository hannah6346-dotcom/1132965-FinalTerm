<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1132936 - FinalTerm</title>
    <style>
        :root {
            --board-color: #e3b866;
            --line-color: #000;
            --grid-size: 40px;
            --stone-size: 34px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            color: #fff;
        }

        h1 {
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }

        .game-info {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            border-radius: 15px;
            backdrop-filter: blur(5px);
            margin-bottom: 20px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.2);
            min-width: 320px;
        }

        .status-bar {
            font-size: 1.2rem;
            font-weight: bold;
            color: #ffd700;
            margin-bottom: 10px;
        }

        .scores {
            display: flex;
            justify-content: space-around;
            margin-top: 10px;
            font-size: 0.9rem;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .score-box { text-align: center; }
        .score-val { font-size: 1.2em; font-weight: bold; }

        .board-container {
            position: relative;
            width: calc(var(--grid-size) * 9 + 40px);
            height: calc(var(--grid-size) * 9 + 40px);
            background-color: var(--board-color);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border-radius: 4px;
            padding: 20px;
            box-sizing: border-box;
            background-image: repeating-linear-gradient(45deg, rgba(0,0,0,0.02) 0px, rgba(0,0,0,0.02) 2px, transparent 2px, transparent 10px);
            transition: transform 0.5s; /* ÁµêÁÆóÊôÇÁöÑÂ∞èÂãïÁï´ */
        }
        
        .board-container.finished {
            transform: scale(1.02);
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.6); /* ÈáëËâ≤ÂÖâÊöà */
            border: 2px solid #ffd700;
        }

        .grid-lines {
            position: absolute;
            top: 20px; left: 20px;
            width: calc(var(--grid-size) * 8);
            height: calc(var(--grid-size) * 8);
            background-image: 
                linear-gradient(var(--line-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--line-color) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            border: 1px solid var(--line-color); /* ‰øÆÊ≠£ÈÇäÊ°Ü */
            pointer-events: none;
        }

        .star-point {
            position: absolute;
            width: 8px; height: 8px;
            background-color: #000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .intersection-layer {
            position: absolute;
            top: 20px; left: 20px;
            width: calc(var(--grid-size) * 8);
            height: calc(var(--grid-size) * 8);
        }

        .intersection {
            position: absolute;
            width: var(--grid-size);
            height: var(--grid-size);
            transform: translate(-50%, -50%);
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
        }
        
        .intersection:hover::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: var(--stone-size);
            height: var(--stone-size);
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.2);
            border-radius: 50%;
        }

        /* Ê£ãÂ≠ê */
        .stone {
            position: absolute;
            width: var(--stone-size);
            height: var(--stone-size);
            border-radius: 50%;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 2px 2px 4px rgba(0,0,0,0.4);
            z-index: 20;
            pointer-events: none;
            transition: transform 0.2s;
        }

        .stone.black { background: radial-gradient(circle at 30% 30%, #444, #000); }
        .stone.white { background: radial-gradient(circle at 30% 30%, #fff, #ddd); }

        .stone.last-move::before {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 10px; height: 10px;
            border-radius: 50%;
            border: 2px solid red;
            box-shadow: 0 0 5px red;
        }
        
        .stone.atari {
            box-shadow: 0 0 10px 4px rgba(255, 0, 0, 0.6);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 5px 2px rgba(255,0,0,0.4); }
            50% { box-shadow: 0 0 12px 5px rgba(255,0,0,0.7); }
            100% { box-shadow: 0 0 5px 2px rgba(255,0,0,0.4); }
        }

        .stone.captured {
            transform: translate(-50%, -50%) scale(0.1);
            opacity: 0;
            transition: all 0.4s ease-in;
        }

        .territory-mark {
            position: absolute;
            width: var(--grid-size);
            height: var(--grid-size);
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            pointer-events: none;
            transition: all 0.5s ease;
            border-radius: 2px;
        }
        
        .territory-black { background-color: rgba(0, 0, 0, 0.4); }
        .territory-white { background-color: rgba(255, 255, 255, 0.4); }

        .board-container.finished .territory-black {
            background-color: rgba(0, 0, 0, 0.85) !important; /* Âπæ‰πé‰∏çÈÄèÊòé */
            box-shadow: inset 0 0 5px rgba(255,255,255,0.2);
            z-index: 6;
        }
        
        .board-container.finished .territory-white {
            background-color: rgba(255, 255, 255, 0.85) !important; /* Âπæ‰πé‰∏çÈÄèÊòé */
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
            z-index: 6;
        }

        .controls {
            margin-top: 25px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }

        .btn-pass { background-color: #f39c12; color: white; }
        .btn-reset { background-color: #e74c3c; color: white; }
        
        button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        button:disabled { background-color: #95a5a6; cursor: not-allowed; transform: none; }

    </style>
</head>
<body>

    <h1>1132936 - FinalTerm</h1>
    
    <div class="game-info">
        <div class="status-bar" id="status">‚ö´ ÈªëÊ£ã (Áé©ÂÆ∂) ‰∏ãÂ≠ê</div>
        <div class="scores">
            <div class="score-box">
                <div>ÈªëÊ£ãÂú∞Áõ§</div>
                <div class="score-val" id="score-black">0</div>
            </div>
            <div class="score-box">
                <div>ÁôΩÊ£ãÂú∞Áõ§</div>
                <div class="score-val" id="score-white">0</div>
                <div style="font-size:0.7em; color:#aaa;">(Âê´Ë≤ºÁõÆ3.5)</div>
            </div>
        </div>
        <div id="pass-msg" style="color: #ffcccc; font-size: 0.9em; height: 20px; margin-top: 5px;"></div>
    </div>

    <div class="board-container" id="board-container">
        <div class="grid-lines">
            <div class="star-point" style="left: calc(var(--grid-size) * 2); top: calc(var(--grid-size) * 2);"></div>
            <div class="star-point" style="left: calc(var(--grid-size) * 6); top: calc(var(--grid-size) * 2);"></div>
            <div class="star-point" style="left: calc(var(--grid-size) * 4); top: calc(var(--grid-size) * 4);"></div>
            <div class="star-point" style="left: calc(var(--grid-size) * 2); top: calc(var(--grid-size) * 6);"></div>
            <div class="star-point" style="left: calc(var(--grid-size) * 6); top: calc(var(--grid-size) * 6);"></div>
        </div>
        
        <div class="intersection-layer" id="board-layer"></div>
    </div>

    <div class="controls">
        <button class="btn-pass" id="btn-pass" onclick="game.pass()">ËÆìÂ≠ê/ËôõÊâã (Pass)</button>
        <button class="btn-reset" onclick="game.reset()">ÈáçÊñ∞ÈñãÂßã</button>
    </div>

    <script>
        const BOARD_SIZE = 9;
        const EMPTY = 0, BLACK = 1, WHITE = 2;

        class GoGame {
            constructor() {
                this.initBoardData();
                this.renderBoardGrid();
                this.updateUI();
            }

            initBoardData() {
                this.board = Array.from({ length: BOARD_SIZE }, () => Array(BOARD_SIZE).fill(EMPTY));
                this.currentPlayer = BLACK;
                this.gameOver = false;
                this.passes = 0;
                this.koPoint = null;
                this.lastMove = null;
            }

            renderBoardGrid() {
                const layer = document.getElementById('board-layer');
                layer.innerHTML = ''; 
                
                for (let r = 0; r < BOARD_SIZE; r++) {
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        // 1. ‰∫íÂãïÈªû
                        const div = document.createElement('div');
                        div.className = 'intersection';
                        div.style.top = `${r * 40}px`;
                        div.style.left = `${c * 40}px`;
                        div.onclick = () => this.handleUserClick(r, c);
                        layer.appendChild(div);

                        // 2. Âú∞Áõ§Ê®ôË®ò (È†êÂÖàÂª∫Á´ãDOMÔºåÈÄèÈÅéclassÊéßÂà∂È°ØÁ§∫)
                        const territoryMark = document.createElement('div');
                        territoryMark.id = `territory-${r}-${c}`;
                        territoryMark.className = 'territory-mark';
                        territoryMark.style.top = `${r * 40}px`;
                        territoryMark.style.left = `${c * 40}px`;
                        layer.appendChild(territoryMark);
                    }
                }
            }

            handleUserClick(r, c) {
                if (this.gameOver || this.currentPlayer !== BLACK) return;
                if (this.playMove(r, c)) {
                    setTimeout(() => this.aiMove(), 400);
                }
            }

            playMove(r, c) {
                if (this.board[r][c] !== EMPTY) return false;

                const originalState = this.copyBoard(this.board);
                this.board[r][c] = this.currentPlayer;

                const opponent = this.currentPlayer === BLACK ? WHITE : BLACK;
                const capturedStones = this.checkCaptures(r, c, opponent);
                
                if (this.koPoint && this.koPoint.r === r && this.koPoint.c === c && capturedStones.length === 1) {
                    this.board = originalState;
                    alert("Âä´Áà≠Ôºö‰∏çËÉΩÁ´ãÂç≥ÂõûÊèêÔºÅ");
                    return false;
                }

                const myLiberties = this.getGroupLiberties(r, c, this.currentPlayer);
                if (myLiberties === 0 && capturedStones.length === 0) {
                    this.board = originalState;
                    alert("Á¶ÅËëóÈªûÔºö‰∏çËÉΩËá™ÊÆ∫ÔºÅ");
                    return false;
                }

                if (capturedStones.length > 0) {
                    this.removeStones(capturedStones);
                }

                if (capturedStones.length === 1 && myLiberties === 0) {
                    this.koPoint = { r: capturedStones[0].r, c: capturedStones[0].c };
                } else {
                    this.koPoint = null;
                }

                this.passes = 0;
                this.lastMove = { r, c };
                
                this.renderStones();
                this.updateRealTimeTerritory(); // Âç≥ÊôÇÊõ¥Êñ∞
                
                this.currentPlayer = opponent;
                this.updateUI();
                return true;
            }

            updateRealTimeTerritory() {
                document.querySelectorAll('.territory-mark').forEach(el => {
                    el.className = 'territory-mark';
                });

                let blackArea = 0;
                let whiteArea = 0;
                const visited = new Set();

                for(let r=0; r<BOARD_SIZE; r++) {
                    for(let c=0; c<BOARD_SIZE; c++) {
                        if (this.board[r][c] === EMPTY && !visited.has(`${r},${c}`)) {
                            const region = this.getRegion(r, c, visited);
                            if (region.owner === BLACK) {
                                blackArea += region.points.length;
                                region.points.forEach(p => this.markTerritory(p.r, p.c, 'black'));
                            } else if (region.owner === WHITE) {
                                whiteArea += region.points.length;
                                region.points.forEach(p => this.markTerritory(p.r, p.c, 'white'));
                            }
                        }
                    }
                }

                for(let r=0; r<BOARD_SIZE; r++) {
                    for(let c=0; c<BOARD_SIZE; c++) {
                        if (this.board[r][c] === BLACK) {
                            blackArea++;
                            this.markTerritory(r, c, 'black');
                        } else if (this.board[r][c] === WHITE) {
                            whiteArea++;
                            this.markTerritory(r, c, 'white');
                        }
                    }
                }

                document.getElementById('score-black').textContent = blackArea;
                document.getElementById('score-white').textContent = whiteArea + 3.5;
                
                return { black: blackArea, white: whiteArea + 3.5 };
            }

            markTerritory(r, c, color) {
                const el = document.getElementById(`territory-${r}-${c}`);
                if (el) el.classList.add(`territory-${color}`);
            }

            pass() {
                if (this.gameOver) return;
                this.passes++;
                document.getElementById('pass-msg').textContent = `${this.currentPlayer === BLACK ? 'ÈªëÊ£ã' : 'ÁôΩÊ£ã'} Pass`;
                
                if (this.passes >= 2) {
                    this.endGame();
                } else {
                    this.currentPlayer = this.currentPlayer === BLACK ? WHITE : BLACK;
                    this.updateUI();
                    if (this.currentPlayer === WHITE) {
                        setTimeout(() => this.aiMove(), 500);
                    }
                }
            }

            aiMove() {
                if (this.gameOver) return;
                const validMoves = [];
                for(let r=0; r<BOARD_SIZE; r++){
                    for(let c=0; c<BOARD_SIZE; c++){
                        if(this.board[r][c] === EMPTY) {
                            let score = Math.random() * 10; 
                            if((r===2||r===6) && (c===2||c===6)) score += 5;
                            if(r===4 && c===4) score += 3;
                            if (this.isValidMoveSim(r, c, WHITE)) {
                                validMoves.push({r, c, score});
                            }
                        }
                    }
                }

                if (validMoves.length === 0) {
                    this.pass();
                    return;
                }
                validMoves.sort((a, b) => b.score - a.score);
                this.playMove(validMoves[0].r, validMoves[0].c);
            }

            isValidMoveSim(r, c, player) {
                const opponent = player === BLACK ? WHITE : BLACK;
                this.board[r][c] = player;
                const caps = this.checkCaptures(r, c, opponent);
                const libs = this.getGroupLiberties(r, c, player);
                this.board[r][c] = EMPTY;
                if (libs === 0 && caps.length === 0) return false;
                return true;
            }

            checkCaptures(r, c, opponent, tempBoard = this.board) {
                const captured = [];
                const neighbors = [[r-1,c], [r+1,c], [r,c-1], [r,c+1]];
                neighbors.forEach(([nr, nc]) => {
                    if (this.isOnBoard(nr, nc) && tempBoard[nr][nc] === opponent) {
                        const group = this.getGroup(nr, nc, opponent, tempBoard);
                        if (this.countLiberties(group, tempBoard) === 0) {
                            captured.push(...group);
                        }
                    }
                });
                return captured;
            }

            getGroup(r, c, color, board = this.board) {
                const group = [];
                const visited = new Set();
                const queue = [{r, c}];
                visited.add(`${r},${c}`);
                while(queue.length > 0) {
                    const curr = queue.pop();
                    group.push(curr);
                    [[curr.r-1,curr.c], [curr.r+1,curr.c], [curr.r,curr.c-1], [curr.r,curr.c+1]].forEach(([nr, nc]) => {
                        if (this.isOnBoard(nr, nc) && board[nr][nc] === color && !visited.has(`${nr},${nc}`)) {
                            visited.add(`${nr},${nc}`);
                            queue.push({r: nr, c: nc});
                        }
                    });
                }
                return group;
            }

            countLiberties(group, board = this.board) {
                const liberties = new Set();
                group.forEach(({r, c}) => {
                    [[r-1,c], [r+1,c], [r,c-1], [r,c+1]].forEach(([nr, nc]) => {
                        if (this.isOnBoard(nr, nc) && board[nr][nc] === EMPTY) liberties.add(`${nr},${nc}`);
                    });
                });
                return liberties.size;
            }

            getGroupLiberties(r, c, color) {
                return this.countLiberties(this.getGroup(r, c, color));
            }

            getRegion(r, c, globalVisited) {
                const points = [];
                const queue = [{r, c}];
                globalVisited.add(`${r},${c}`);
                let touchesBlack = false;
                let touchesWhite = false;

                while(queue.length > 0) {
                    const curr = queue.pop();
                    points.push(curr);
                    [[curr.r-1,curr.c], [curr.r+1,curr.c], [curr.r,curr.c-1], [curr.r,curr.c+1]].forEach(([nr, nc]) => {
                        if (this.isOnBoard(nr, nc)) {
                            if (this.board[nr][nc] === BLACK) touchesBlack = true;
                            else if (this.board[nr][nc] === WHITE) touchesWhite = true;
                            else if (!globalVisited.has(`${nr},${nc}`)) {
                                globalVisited.add(`${nr},${nc}`);
                                queue.push({r: nr, c: nc});
                            }
                        }
                    });
                }
                
                let owner = null;
                if (touchesBlack && !touchesWhite) owner = BLACK;
                if (!touchesBlack && touchesWhite) owner = WHITE;
                return { points, owner };
            }

            removeStones(stones) {
                stones.forEach(({r, c}) => {
                    const stoneEl = document.getElementById(`stone-${r}-${c}`);
                    if(stoneEl) stoneEl.classList.add('captured');
                    this.board[r][c] = EMPTY;
                });
                setTimeout(() => this.renderStones(), 300);
            }

            isOnBoard(r, c) { return r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE; }
            copyBoard(board) { return board.map(row => [...row]); }

            renderStones() {
                document.querySelectorAll('.stone').forEach(el => {
                    if(!el.classList.contains('captured')) el.remove();
                });
                setTimeout(() => document.querySelectorAll('.captured').forEach(el => el.remove()), 300);

                const layer = document.getElementById('board-layer');
                for(let r=0; r<BOARD_SIZE; r++) {
                    for(let c=0; c<BOARD_SIZE; c++) {
                        if(this.board[r][c] !== EMPTY) {
                            const stone = document.createElement('div');
                            stone.className = `stone ${this.board[r][c] === BLACK ? 'black' : 'white'}`;
                            stone.id = `stone-${r}-${c}`;
                            stone.style.top = `${r * 40}px`;
                            stone.style.left = `${c * 40}px`;
                            
                            if (this.lastMove && this.lastMove.r === r && this.lastMove.c === c) {
                                stone.classList.add('last-move');
                            }
                            if (this.getGroupLiberties(r, c, this.board[r][c]) === 1) {
                                stone.classList.add('atari');
                            }
                            layer.appendChild(stone);
                        }
                    }
                }
            }

            updateUI() {
                const status = document.getElementById('status');
                if (this.gameOver) return;
                status.textContent = this.currentPlayer === BLACK ? "‚ö´ ÈªëÊ£ã (Áé©ÂÆ∂) ‰∏ãÂ≠ê" : "‚ö™ ÁôΩÊ£ã (ÈõªËÖ¶) ÊÄùËÄÉ‰∏≠...";
            }

            endGame() {
                this.gameOver = true;
                
                document.getElementById('board-container').classList.add('finished');
                
                const finalScore = this.updateRealTimeTerritory();
                
                setTimeout(() => {
                    let resultText = `ÈõôÊñπ PassÔºåÈÅäÊà≤ÁµêÊùüÔºÅ\n\n`;
                    resultText += `‚ö´ ÈªëÊ£ãÁ∏ΩÂú∞: ${finalScore.black}\n`;
                    resultText += `‚ö™ ÁôΩÊ£ãÁ∏ΩÂú∞: ${finalScore.white}\n\n`;
                    
                    if (finalScore.black > finalScore.white) {
                        resultText += "üèÜ ÈªëÊ£ãÂãùÔºÅ";
                        document.getElementById('status').textContent = "üèÜ ÈªëÊ£ãÁç≤Âãù";
                        document.getElementById('status').style.color = "#2ecc71";
                    } else {
                        resultText += "üíª ÁôΩÊ£ãÂãùÔºÅ";
                        document.getElementById('status').textContent = "üíª ÁôΩÊ£ãÁç≤Âãù";
                    }
                    
                    document.getElementById('btn-pass').disabled = true;
                    alert(resultText);
                    
                }, 100); 
            }

            reset() {
                document.getElementById('board-container').classList.remove('finished');
                
                this.initBoardData();
                this.renderBoardGrid();
                this.updateRealTimeTerritory();
                document.getElementById('pass-msg').textContent = "";
                document.getElementById('btn-pass').disabled = false;
                document.getElementById('status').style.color = "#ffd700";
                this.updateUI();
            }
        }

        let game;
        window.onload = () => { game = new GoGame(); };
    </script>
</body>
</html>

